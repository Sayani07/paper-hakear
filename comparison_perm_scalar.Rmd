---
title: "Compare permutation and scalar transformation approaches on simulated and real data"
author: "Sayani Gupta"
output:
  bookdown::pdf_book:
    #base_format: rticles::asa_article
    fig_height: 5
    fig_width: 8
    fig_caption: yes
    dev: "pdf"
    toc: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      eval = TRUE,
                      warning = FALSE,
                      message = FALSE)
knitr::read_chunk("example_transformations.R")
library(tidyverse)
library(readr)
library(ggplot2)
library(here)
```


# Simulated data


## Data generation

Observations are generated from a Gamma(2,1) distribution for each combination of $nx$ and $nfacet$ from the following sets: $nx = nfacet = \{2, 3, 5, 7, 14, 20, 31, 50\}$ to cover a wide range of levels from very low to moderately high. Each combination is being referred to as a _panel_. That is, data is being generated for each of the panels $\{nx = 2, nfacet = 2\}, \{nx = 2, nfacet = 3\}, \{nx = 2, nfacet = 5\},  \dots, \{nx = 50, nfacet = 31\}, \{nx = 50, nfacet = 50\}$. For each of the $64$ panels, $ntimes = 500$ observations are drawn for each combination of the categories. That is, if we consider the panel  $\{nx = 2, nfacet = 2\}$, $500$ observations are generated for each of the combination of categories from the panel, namely, $\{(1, 1), (1, 2), (2, 1), (2, 2)\}$. The values of $\lambda$ is set to $0.67$ and values of raw wpd $wpd_{raw}$ is obtained.


## Scalar transformation approach to normalisation

A log-linear model is fitted to see how the values of $wpd_{raw}$ changes with the values of $nx$ and $nfacet$. The model is of the form $$y = a+b*log(x) +e$$, where $y = median(wpd_{raw})$ and $x = nx*nfacet$. $wpd_norm$ is a transformation on $wpd_{raw}$ which should be designed to remove the effect of $nx*nfacet$ on $wpd_{raw}$ and thus is defined as follows:
$wpd_{norm} = wpd_{raw} - b*log(nx*nfacet)$


## Permutation approach to normalisation

The simulated data for each of the panels is permuted/shuffled $nperm = 200$ times and for each of those permutations $wpd_{norm}$ is computed as follows: $wpd_{norm} =  (wpd_{raw} - mean(wpd_{raw}))/sd(wpd_{raw})$
. This is done so that the distribution of the normalised measure $wpd_{norm}$ has the same mean and standard deviation across different nx and nfacet.


## Comparing the two approaches

In Figure \ref{fig:dist-new-approx}, we see that the distribution of $wpd_{norm2} = wpd_{raw} - b*log(nx*nfacet)$ is similar when normalised with true or approximate estimate of b. Morever, the distributions are pretty similar across different nx and nfacet.

```{r dist-new-approx, echo = FALSE, fig.cap = " The distribution of $wpd_{norm2}$ is plotted for approximate estimate of b. The distributions are similar when plotted against true and approxiomate estimate and b."}

G21 <- read_rds(here("simulations/raw/null_design_quantrans/data-agg/all_data_wpd_Gamma21.rds"))

G21_median <- G21 %>% 
  group_by(nx*nfacet) %>% 
  summarise(actual = median(value))


# fit model median to log(nx*nfacet)
fit_lm2 <- lm(actual ~ poly(log(`nx * nfacet`) ,1, raw=TRUE), data = G21_median)

summary(fit_lm2)

intercept <- fit_lm2$coefficients[1]
slope <- fit_lm2$coefficients[2]


G21 %>% 
  ggplot(aes(x=log(nx*nfacet), y = (value - slope*log(nx*nfacet)))) +
  geom_point() + stat_summary(fun=mean, geom="line", aes(group=1), color = "blue") + 
  xlab("$wpd_norm =  wpd_raw - slope*log(nx*nfacet)$")


G21_permutation <- read_rds("simulations/norm/null_design_quantrans_nperm/data-agg/all_data_wpd_Gamma21.rds") %>% 
  rename("wpd_permutation" = "value")

G21_all_data <- G21 %>% 
  mutate(wpd_exact_est = (value - slope*log(nx*nfacet)),
                               
                          wpd_approx_est = (value - 0.0027*log(nx*nfacet))) %>% 
  pivot_longer(cols = 5:6,
               names_to = "type_estimate",
               values_to = "value_estimate")

G21_all_data %>% 
  ggplot() +
  geom_density(aes(x = value_estimate, 
                   fill = type_estimate), 
               alpha = 0.5) +
  facet_grid(nx~nfacet,
             labeller = "label_both") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("#0072B2", "#D55E00", "#CC79A7")) +
  xlab("wpd_norm2")
```


```{r wpd-permutation-d, fig.cap = " The distribution of $wpd_{permutation}$ is plotted. The distributions are more similar across different nx and nfacet (specially for small nx and nfacet) but this approach has the downside of more computational time."}

G21_permutation %>% 
    ggplot() +
  geom_density(aes(x = wpd_permutation), 
                   fill = "blue") +
  facet_grid(nx~nfacet,
             labeller = "label_both") +
  theme(legend.position = "bottom") 
```  

<!-- # left_join(G21_permutation, -->
<!-- #                                   by = c("nx", "nfacet", "perm_id")) %>%  -->
<!-- #   rename("wpd_raw" = "value.x", -->
<!-- #          "wpd_permutation" = "value.y") -->
<!-- ``` -->

## Ranking different designs

```{r}
data <- read_rds("simulations/supplementary/data-agg/wpd_N01/all_data.rds")

# data_validate <-  data %>% 
#   filter(
#     nperm == 10, ntimes == 100, w == 1
#   ) %>% 
#   pivot_wider(id_cols = -2,
#               names_from = design,
#               values_from = value) %>% 
#   mutate(right_order = ((null<=vary_f<=vary_x)))

data_filter <- data %>% 
    filter(
        nperm == 10, ntimes == 100, w == 1
    ) 


data_filter %>% 
    pivot_wider(id_cols = -2,
                names_from = design,
                values_from = value) %>% 
    mutate(right_order = (null <= min(null, vary_f, vary_x))) 
             
  #            
  #            ((null<=vary_f) & (vary_f<=vary_x))) %>% 
  # mutate(right_order_proxy = if_else(right_order==TRUE, 1, 0)) %>% 
  # group_by(nx, nfacet) %>% 
  # summarise(n_order =  sum(right_order_proxy)/200) %>% View()
  
data_filter %>% 
  mutate(value = value - 0.0027*log(nx*nfacet)) %>% 
    pivot_wider(id_cols = -2,
                names_from = design,
                values_from = value) %>% 
    mutate(right_order = ((null<=vary_f) & (vary_f<=vary_x))) %>% 
  mutate(right_order_proxy = if_else(right_order==TRUE, 1, 0)) %>% 
  group_by(nx, nfacet) %>% 
  summarise(n_order =  sum(right_order_proxy)/200) %>% View

```


# Real Data

- Check if the ranking of the harmonies from the two approaches (wpd_norm_perm and  wpd_norm_scalar) are similar or not?

- Check if the threshold is visually too different


```{r}
all_data_perm <- read_rds("paper/sim_table/all_data.rds")

#all_data_scalar <- 
```


- the two approaches permutation and modelling could be brought to the same scale so that for smaller categories, permutation could be done and for larger categories, stick to modelling approach


## bringing both to the same scale also helps means you have a lower and upper bound for the normalised wpd


```{r dist-new-same-scale}

G21 <- read_csv("simulations/raw/null_design_quantrans/data-agg/all_data_wpd_N01.csv")

G21_median <- G21 %>% 
  group_by(nx*nfacet) %>% 
  summarise(actual = median(value))


# fit model median to log(nx*nfacet)
fit_lm2 <- lm(actual ~ poly(log(`nx * nfacet`) ,1, raw=TRUE), data = G21_median)

summary(fit_lm2)

beta_lm2 <- lm(actual ~ log(`nx * nfacet`), data = G21_median)

summary(fit_lm2)


beta_lm2 <- lm(actual ~ log(`nx * nfacet`), data = G21_median)

summary(fit_lm2)


intercept <- fit_lm2$coefficients[1]
slope <- fit_lm2$coefficients[2]


G21 %>% 
  ggplot(aes(x=log(nx*nfacet), y = (value - intercept -slope*log(nx*nfacet)))) +
  geom_point() + stat_summary(fun=mean, geom="line", aes(group=1), color = "blue") + 
  xlab("$wpd_norm =  wpd_raw - slope*log(nx*nfacet)$")


G21_permutation <- read_rds("simulations/norm/null_design_quantrans_nperm/data-agg/all_data_wpd_Gamma21.rds") %>% 
  rename("wpd_permutation" = "value")


G21_model_data <- G21 %>% 
  mutate(model =
           (value - intercept - 0.0027*log(nx*nfacet))/0.0027
         ) %>% 
  mutate(model_trans = 
           (model - min(model))/(max(model) - min(model)))

G21_model_data$model %>% summary()
G21_model_data$model_trans %>% summary()


G21_perm_data <- G21_permutation %>% 
  mutate(perm_trans =
           (
             (wpd_permutation - min(wpd_permutation))/
                (
                  max(wpd_permutation) - min(wpd_permutation)
                )
             )
           )

G21_all_data <- G21_model_data %>% 
  left_join(G21_perm_data, by = c("nx", "nfacet", "perm_id")) %>% 
  pivot_longer(cols = c(6,8),
               names_to = "type_estimate",
               values_to = "value_estimate")


G21_all_data %>% 
  ggplot() +
  geom_density(aes(x = value_estimate, 
                   fill = type_estimate), 
               alpha = 0.7) +
  facet_grid(nx~nfacet,
             labeller = "label_both") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("#0072B2", "#CC79A7")) +
  xlab("wpd_norm2")
```


```{r wpd-permutation, fig.cap = " The distribution of $wpd_{permutation}$ is plotted. The distributions are more similar across different nx and nfacet (specially for small nx and nfacet) but this approach has the downside of more computational time."}

G21_perm_data %>% 
    ggplot() +
  geom_density(aes(x = perm_trans), 
                   fill = "blue") +
  facet_grid(nx~nfacet,
             labeller = "label_both") +
  theme(legend.position = "bottom") 
```  

# bringing both to same scale

```{r}
data <- read_rds("simulations/supplementary/data-agg/wpd_N01/all_data.rds")

# data_validate <-  data %>% 
#   filter(
#     nperm == 10, ntimes == 100, w == 1
#   ) %>% 
#   pivot_wider(id_cols = -2,
#               names_from = design,
#               values_from = value) %>% 
#   mutate(right_order = ((null<=vary_f<=vary_x)))

data_filter <- data %>% 
    filter(
        nperm == 10, ntimes == 100, w == 1
    ) 


data_filter %>% 
    pivot_wider(id_cols = -2,
                names_from = design,
                values_from = value) %>% 
    mutate(right_order = (null <= min(null, vary_f, vary_x))) 
             
  #            
  #            ((null<=vary_f) & (vary_f<=vary_x))) %>% 
  # mutate(right_order_proxy = if_else(right_order==TRUE, 1, 0)) %>% 
  # group_by(nx, nfacet) %>% 
  # summarise(n_order =  sum(right_order_proxy)/200) %>% View()
  
data_filter %>% 
  mutate(value = value - 0.0027*log(nx*nfacet)) %>% 
    pivot_wider(id_cols = -2,
                names_from = design,
                values_from = value) %>% 
    mutate(right_order = ((null<=vary_f) & (vary_f<=vary_x))) %>% 
  mutate(right_order_proxy = if_else(right_order==TRUE, 1, 0)) %>% 
  group_by(nx, nfacet) %>% 
  summarise(n_order =  sum(right_order_proxy)/200) %>% View

```


# Real Data

- Check if the ranking of the harmonies from the two approaches (wpd_norm_perm and  wpd_norm_scalar) are similar or not?

- Check if the threshold is visually too different


```{r}
all_data_perm <- read_rds("paper/sim_table/all_data.rds")

#all_data_scalar <- 
```


- the two approaches permutation and modelling could be brought to the same scale so that for smaller categories, permutation could be done and for larger categories, stick to modelling approach


## bringing both to the same scale also helps means you have a lower and upper bound for the normalised wpd



# the following looks right where the $wpd_{norm}$ are just plotted like that and the model is GLM with distribution Gamma and link-function inverse

```{r dist-new-same-scale-link}

G21 <- read_csv("simulations/raw/null_design_quantrans/data-agg/all_data_wpd_N01.csv")

G21_median <- G21 %>% 
  group_by(nx*nfacet) %>% 
  summarise(actual = median(value))


# fit model median to log(nx*nfacet)
# fit_lm2 <- lm(actual ~ poly(log(`nx * nfacet`) ,1, raw=TRUE), data = G21_median)
# 
# summary(fit_lm2)

glm_fit <- glm(actual ~ log(`nx * nfacet`),
              family = Gamma(link = "inverse"),
              data = G21_median)

summary(glm_fit)


intercept <- glm_fit$coefficients[1]
slope <- glm_fit$coefficients[2]


G21 %>% 
  ggplot(aes(x=log(nx*nfacet),
             y = ((1/value)
                  - intercept - 
                    slope*log(nx*nfacet))/slope)) +
  geom_point() + stat_summary(fun=mean, geom="line", aes(group=1), color = "blue")


G21_permutation <- read_rds("simulations/norm/null_design_quantrans_nperm/data-agg/all_data_wpd_Gamma21.rds") %>% 
  rename("wpd_permutation" = "value")


G21_model_data <- G21 %>% 
  mutate(model =
           ((1/value)
                  - intercept - 
                    slope*log(nx*nfacet))/slope) %>% 
  mutate(model_trans = 
           (model - mean(model))/sd(model))
         
         
G21_model_data$model %>% summary()

G21_perm_data <- G21_permutation %>% 
  mutate(perm_trans =
           (
             (wpd_permutation - min(wpd_permutation))/
                (
                  max(wpd_permutation) - min(wpd_permutation)
                )
             )
           )

G21_all_data <- G21_model_data %>% 
  left_join(G21_perm_data, by = c("nx", "nfacet", "perm_id")) %>% 
  pivot_longer(cols = c(6,7),
               names_to = "type_estimate",
               values_to = "value_estimate")


G21_all_data %>% 
  ggplot() +
  geom_density(aes(x = value_estimate, 
                   fill = type_estimate), 
               alpha = 0.7) +
  facet_grid(nx~nfacet,
             labeller = "label_both") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("#CC79A7", "#0072B2")) +
  xlab("wpd_norm2")

# are scales same

G21_model_data %>%
  group_by(nx, nfacet) %>% 
  summarise(sd_model = sd(model))



```


